#include <iostream>
#include <string>
#include <stack>

using namespace std;

// структура, описывающая тесты для функции check_brackets(string source)
struct test {
	bool ret_value;		// ожидаемое значение, которое должна вернуть тестируемая функция
	string arg;			// аргумент функции
};

// глобальный массив, содержащий тесты
test tests[] = {
		{true, "{}"}, // 1 - одна пара скобок
		{true, "([])"}, // 2 - скобки внутри скобок
		{true, "()([])"}, // 3 - 1 и 2 вместе
		{true, "{[[()]()]}"}, // 4 - скобки закрываются не подряд
		{true, "(({{[[]]}}))"}, // 5 - несколько пар скобок каждого вида
		{true, "(aa[00]222)"}, // 6 - наличие других символов (не скобок)
		{true, "12*(a+3)+b[0]"}, // 7 - наличие других символов (не скобок)
		{true, "a = b[((5+c)*d)]"}, // 8 - наличие пробелов
		{false, "{[(]}"}, // 9 - непарная открывающаяся скобка
		{false, "{[[()}]()]"}, // 10 - неправильный поряд закрытия
		{false, "}{}{"}, // 11 - закрывающася скобка перед открывающейся
		{false, "[(){}]]"}, // 12 - непарная закрывающася скобка
		{false, "(())[{[]]}"}, // 13 - аналог. 10
		{false, "({][[])}"}, // 14 - 10 и 11 вместе
};

/* Функция возвращает значение true в случае валидной расстановки скобок и false в случае невалидной расстановки скобок. */
/* Валидной считается такая расстановка скобок, при которой каждой открывающейся скобке соответсвует парная закрывающаяся, */
/* причем скобки не должны "перемешиваться" - открывающаяся скобка должна идти перед закрывающейся, */
/* первая открытая скобка должна закрываться последней */
/* Пример валидной строки: "([])"  */
/* Пример невалидные строки: "{[(]}" */
bool check_brackets(string source)
{
	stack <char> brackets;		// для хранения скобок, найденных в строке, будем использовать стек

	for (auto cur : source)		// проверяем всю строку поэлементно, ищем скобки
	{
		if ((cur == '(') || (cur == '{') || (cur == '['))		// если нашли открывающуюся скобку
			brackets.push(cur);									// кладем ее в стек
		else
			if ((cur == ')') || (cur == '}') || (cur == ']'))	// если нашли закрывающуюся скобку
			{
				// если стек пуст, то закрывающихся скобок больше, либо первая скобка - открывающася
				if (brackets.empty())
					return false;								// выход из функции, скобки расставлены неверно

				char stack_top = brackets.top();				// получаем верхний элемент стека
				switch (cur)									// там должна быть соответствующая открывающася скобка
				{
				case ')':
					if (stack_top == '(')					// если на вершине стека нужная скобка
					{
						brackets.pop();						// удаляем верхний элемент
						break;								// выход из оператора (проверяем строку дальше)
					}
					else									// скобка не подошла => скобки в строке расставлены неверно
						return false;						// выход из функции

				case '}':
					if (stack_top == '{')					// если на вершине стека нужная скобка
					{
						brackets.pop();						// удаляем верхний элемент
						break;								// выход из оператора (проверяем строку дальше)
					}
					else									// скобка не подошла => скобки в строке расставлены неверно
						return false;						// выход из функции

				case ']':
					if (stack_top == '[')						// если на вершине стека нужная скобка
					{
						brackets.pop();						// удаляем верхний элемент
						break;								// выход из оператора (проверяем строку дальше)
					}
					else									// скобка не подошла => скобки в строке расставлены неверно
						return false;						// выход из функции
				}

			}
	}

	if (brackets.empty())	// если для каждой открывающейся скобки была найдена пара, то стек будет пуст
		return true;		// скобки в строке расставлены корретно
	else					// если в стеке остались открывающиеся скобки
		return false;		// скобки в строке расставлены неверно
}

int main()
{
	int counter = 1;		// счетчик тестов
	for (auto cur_test : tests)
	{
		int ret = check_brackets(cur_test.arg);
		(cur_test.ret_value == ret) ? cout << "OK" : cout << "Failed";
		cout << " : " << counter++ << " (" << cur_test.ret_value << " : " << ret << ")" << endl;
	}

	return 0;
}